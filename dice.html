<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Dice (Two, Rounded – non-module)</title>
  <style>
    body { margin: 0; background: #2c3e50; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<!-- three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- RoundedBoxGeometry'nin UMD/global sürümü -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>

<script>
let scene, camera, renderer;
let dice1, dice2;
let rolling = false;

init();
animate();

// Zar yüzlerini çiz (pip / nokta)
function drawFace(pipCount) {
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');

  // Arka plan (beyaz zar)
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, 256, 256);

  // Pipler
  ctx.fillStyle = '#000';
  const pipRadius = 20;

  // 3x3 grid
  const positions = [
    [64, 64], [128, 64], [192, 64],
    [64, 128],[128, 128],[192, 128],
    [64, 192],[128, 192],[192, 192]
  ];

  const pipPatterns = {
    1: [4],
    2: [0, 8],
    3: [0, 4, 8],
    4: [0, 2, 6, 8],
    5: [0, 2, 4, 6, 8],
    6: [0, 2, 3, 5, 6, 8]
  };

  pipPatterns[pipCount].forEach(idx => {
    const [x, y] = positions[idx];
    ctx.beginPath();
    ctx.arc(x, y, pipRadius, 0, Math.PI * 2);
    ctx.fill();
  });

  const tex = new THREE.CanvasTexture(canvas);
  tex.anisotropy = 8;
  tex.needsUpdate = true;
  return tex;
}

function makeDice(cornerRadius = 0.1, segments = 4) {
  // Köşeleri yumuşatılmış küp
  const geometry = new THREE.RoundedBoxGeometry(1, 1, 1, segments, cornerRadius);

  // Yüz dokuları (1..6)
  const faceTextures = [1,2,3,4,5,6].map(n => drawFace(n));

  // Her yüz için ayrı malzeme
  const materials = faceTextures.map(tex => new THREE.MeshStandardMaterial({
    map: tex,
    roughness: 0.55,
    metalness: 0.0
  }));

  const mesh = new THREE.Mesh(geometry, materials);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Işıklar
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 5, 5);
  light.castShadow = true;
  scene.add(light);

  const ambient = new THREE.AmbientLight(0x404040, 1.2);
  scene.add(ambient);

  // Hafif zemin (gölge için)
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(10, 10),
    new THREE.MeshStandardMaterial({ color: 0x222831, roughness: 1 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.7;
  ground.receiveShadow = true;
  scene.add(ground);

  // İki zar
  dice1 = makeDice(0.1, 4);
  dice2 = makeDice(0.1, 4);

  dice1.position.set(-0.8, 0, 0);
  dice2.position.set( 0.8, 0, 0);

  dice1.rotation.set(0.2, 0.4, 0.1);
  dice2.rotation.set(-0.3, 0.1, 0.25);

  scene.add(dice1);
  scene.add(dice2);

  camera.position.set(0, 0.2, 4);
  camera.lookAt(0, 0, 0);

  window.addEventListener('resize', onWindowResize, false);
  document.body.addEventListener('click', rollDice);
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') rollDice();
  });
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function rollDice() {
  if (rolling) return;
  rolling = true;

  const r1 = Math.floor(Math.random() * 6) + 1;
  const r2 = Math.floor(Math.random() * 6) + 1;

  const xRot1 = (Math.floor(Math.random() * 4) + 1) * Math.PI / 2;
  const yRot1 = (Math.floor(Math.random() * 4) + 1) * Math.PI / 2;
  const xRot2 = (Math.floor(Math.random() * 4) + 1) * Math.PI / 2;
  const yRot2 = (Math.floor(Math.random() * 4) + 1) * Math.PI / 2;

  let step = 0;
  const totalSteps = 30;

  const s1x = dice1.rotation.x, s1y = dice1.rotation.y;
  const s2x = dice2.rotation.x, s2y = dice2.rotation.y;

  const e1x = s1x + (Math.PI * 4) + xRot1;
  const e1y = s1y + (Math.PI * 4) + yRot1;
  const e2x = s2x + (Math.PI * 4) + xRot2;
  const e2y = s2y + (Math.PI * 4) + yRot2;

  const interval = setInterval(() => {
    step++;
    const t = step / totalSteps;

    dice1.rotation.x = s1x + (e1x - s1x) * t;
    dice1.rotation.y = s1y + (e1y - s1y) * t;
    dice2.rotation.x = s2x + (e2x - s2x) * t;
    dice2.rotation.y = s2y + (e2y - s2y) * t;

    if (step >= totalSteps) {
      clearInterval(interval);
      rolling = false;

      const q = Math.PI / 2;
      dice1.rotation.x = Math.round(dice1.rotation.x / q) * q;
      dice1.rotation.y = Math.round(dice1.rotation.y / q) * q;
      dice2.rotation.x = Math.round(dice2.rotation.x / q) * q;
      dice2.rotation.y = Math.round(dice2.rotation.y / q) * q;

      const payload = { d1: r1, d2: r2, total: r1 + r2 };

      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify(payload));
      } else if (window.webkit?.messageHandlers?.diceResult) {
        window.webkit.messageHandlers.diceResult.postMessage(payload);
      } else {
        console.log("Zar sonuçları:", payload);
      }
    }
  }, 16);
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>
