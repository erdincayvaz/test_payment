<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Dice (Top View + 1 Bounce + Face Match + One Shot, WebCrypto)</title>
  <style>
    body { margin: 0; background: #2c3e50; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>

<script>
let scene, camera, renderer;
let dice1, dice2;
let rolling = false;
let hasRolled = false;
let clock = new THREE.Clock();

// 🔒 Tek atış kilidi
let lock = false;
let onClickRef = null;
let onKeyRef = null;

init();
animate();

function lockAfterFirstRoll() {
  lock = true;
  if (onClickRef) document.body.removeEventListener('click', onClickRef);
  if (onKeyRef) removeEventListener('keydown', onKeyRef);
}

/* ---------- WebCrypto RNG ---------- */
// Mod bias'ı önlemek için 0..255 aralığından al, 252..255'i reddet
function rollCrypto() {
  const buf = new Uint8Array(1);
  do { crypto.getRandomValues(buf); } while (buf[0] >= 252);
  return (buf[0] % 6) + 1; // 1..6
}

/* ---------- texture & materials ---------- */
function drawFace(pipCount) {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  const g = c.getContext('2d');

  g.fillStyle = '#fff';
  g.fillRect(0, 0, 256, 256);

  g.fillStyle = '#000';
  const r = 20;
  const pos = [
    [64,64],[128,64],[192,64],
    [64,128],[128,128],[192,128],
    [64,192],[128,192],[192,192]
  ];
  const pat = {
    1:[4],
    2:[0,8],
    3:[0,4,8],
    4:[0,2,6,8],
    5:[0,2,4,6,8],
    6:[0,2,3,5,6,8],
  };
  pat[pipCount].forEach(i=>{
    const [x,y]=pos[i];
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  });

  const tex = new THREE.CanvasTexture(c);
  tex.anisotropy = 8; tex.needsUpdate = true;
  return tex;
}

function makeDice(cornerRadius = 0.1, segments = 4) {
  const geom = new THREE.RoundedBoxGeometry(1,1,1,segments,cornerRadius);

  const t1 = drawFace(1), t2 = drawFace(2), t3 = drawFace(3),
        t4 = drawFace(4), t5 = drawFace(5), t6 = drawFace(6);

  // three.js face order: [+X, -X, +Y, -Y, +Z, -Z]
  // mapping: top=1, bottom=6, front=2, back=5, right=3, left=4
  const mats = [
    new THREE.MeshStandardMaterial({ map: t3, roughness:0.55 }), // +X -> 3
    new THREE.MeshStandardMaterial({ map: t4, roughness:0.55 }), // -X -> 4
    new THREE.MeshStandardMaterial({ map: t1, roughness:0.55 }), // +Y -> 1
    new THREE.MeshStandardMaterial({ map: t6, roughness:0.55 }), // -Y -> 6
    new THREE.MeshStandardMaterial({ map: t2, roughness:0.55 }), // +Z -> 2
    new THREE.MeshStandardMaterial({ map: t5, roughness:0.55 })  // -Z -> 5
  ];

  const mesh = new THREE.Mesh(geom, mats);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

/* ---------- easing & tween ---------- */
function easeInQuad(t){ return t*t; }
function easeOutQuad(t){ return t*(2-t); }
function tween(duration, onUpdate){
  return new Promise(res=>{
    const start = performance.now();
    function step(now){
      const t = Math.min(1, (now-start)/duration);
      onUpdate(t);
      if(t<1) requestAnimationFrame(step); else res();
    }
    requestAnimationFrame(step);
  });
}

/* ---------- one-bounce drop ---------- */
async function bounceOnce(mesh, {
  groundY,
  dropDuration=220,
  bounceHeight=0.12,
  upDuration=180,
  downDuration=200
}={}){
  const startY = mesh.position.y;
  await tween(dropDuration, t=>{
    const k = easeInQuad(t);
    mesh.position.y = startY + (groundY - startY) * k;
  });

  const peakY = groundY + bounceHeight;
  await tween(upDuration, t=>{
    const k = easeOutQuad(t);
    mesh.position.y = groundY + (peakY - groundY) * k;
  });

  await tween(downDuration, t=>{
    const k = easeInQuad(t);
    mesh.position.y = peakY + (groundY - peakY) * k;
  });

  mesh.position.y = groundY;
}

/* ---------- orientation helpers ---------- */
function randomRotation(mesh){
  const q = Math.PI/2;
  const rx = Math.floor(Math.random()*4)*q;
  const ry = Math.floor(Math.random()*4)*q;
  const rz = (Math.random()-0.5)*0.5; // ~±14°
  mesh.rotation.set(rx, ry, rz);
}

function setTopFace(mesh, value){
  // rotasyonu sıfırla
  mesh.rotation.set(0, 0, 0);

  // hedef yüzü +Y yönüne getir
  switch (value) {
    case 1: break;
    case 6: mesh.rotation.x = Math.PI;         break;
    case 2: mesh.rotation.x = -Math.PI / 2;    break;
    case 5: mesh.rotation.x =  Math.PI / 2;    break;
    case 3: mesh.rotation.z =  Math.PI / 2;    break;
    case 4: mesh.rotation.z = -Math.PI / 2;    break;
  }

  // köşe hizalama
  const q = Math.PI / 2;
  mesh.rotation.x = Math.round(mesh.rotation.x / q) * q;
  mesh.rotation.y = Math.round(mesh.rotation.y / q) * q;
  mesh.rotation.z = Math.round(mesh.rotation.z / q) * q;
}

/* --- ekrandaki üst yüzü ölç --- */
function getTopFace(mesh){
  const up = new THREE.Vector3(0,1,0);
  const dirs = {
    '+X': new THREE.Vector3(1,0,0),
    '-X': new THREE.Vector3(-1,0,0),
    '+Y': new THREE.Vector3(0,1,0),
    '-Y': new THREE.Vector3(0,-1,0),
    '+Z': new THREE.Vector3(0,0,1),
    '-Z': new THREE.Vector3(0,0,-1),
  };
  for (const k in dirs) dirs[k].applyQuaternion(mesh.quaternion);

  let bestKey = '+Y', bestDot = -Infinity;
  for (const k in dirs){
    const d = dirs[k].dot(up);
    if (d > bestDot){ bestDot = d; bestKey = k; }
  }
  const map = { '+X':3, '-X':4, '+Y':1, '-Y':6, '+Z':2, '-Z':5 };
  return map[bestKey] || 1;
}

/* ---------- scene ---------- */
function init(){
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,5,3);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lights
  const dir = new THREE.DirectionalLight(0xffffff, 1);
  dir.position.set(5,5,5);
  dir.castShadow = true;
  scene.add(dir);

  const amb = new THREE.AmbientLight(0x404040, 1.2);
  scene.add(amb);

  // ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(10,10),
    new THREE.MeshStandardMaterial({ color:0x222831, roughness:1 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.7;
  ground.receiveShadow = true;
  scene.add(ground);

  // dice
  dice1 = makeDice(0.1, 4);
  dice2 = makeDice(0.1, 4);
  dice1.position.set(-0.8, 0.5, 0);
  dice2.position.set( 0.8, 0.5, 0);

  randomRotation(dice1);
  randomRotation(dice2);

  scene.add(dice1); scene.add(dice2);

  // rest height for centers: ground.y + half cube
  scene.userData.groundY = ground.position.y + 0.5;

  addEventListener('resize', onResize);

  // olayları referansla ekle
  onClickRef = () => rollDice();
  document.body.addEventListener('click', onClickRef);

  onKeyRef = (e) => { if (e.code === 'Space') rollDice(); };
  addEventListener('keydown', onKeyRef);

  clock.start();
}

function onResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

/* ---------- roll (WebCrypto ile) ---------- */
function rollDice(){
  if (lock || rolling) return;
  rolling = true;
  hasRolled = true;

  // 🔐 WebCrypto tabanlı zar
  const r1 = rollCrypto();
  const r2 = rollCrypto();

  // hızlı spin: 10..14 çeyrek tur
  const q = Math.PI/2;
  const addX1 = (Math.floor(Math.random()*5)+10) * q;
  const addY1 = (Math.floor(Math.random()*5)+10) * q;
  const addX2 = (Math.floor(Math.random()*5)+10) * q;
  const addY2 = (Math.floor(Math.random()*5)+10) * q;

  let step=0, total=60;
  const s1x=dice1.rotation.x, s1y=dice1.rotation.y;
  const s2x=dice2.rotation.x, s2y=dice2.rotation.y;
  const e1x=s1x+addX1, e1y=s1y+addY1;
  const e2x=s2x+addX2, e2y=s2y+addY2;

  const interval = setInterval(async ()=>{
    step++;
    const t = step/total;

    dice1.rotation.x = s1x + (e1x-s1x)*t;
    dice1.rotation.y = s1y + (e1y-s1y)*t;
    dice2.rotation.x = s2x + (e2x-s2x)*t;
    dice2.rotation.y = s2y + (e2y-s2y)*t;

    if (step>=total){
      clearInterval(interval);

      // üst yüzü sonuçla eşleştir
      setTopFace(dice1, r1);
      setTopFace(dice2, r2);

      // ölç → logla
      const v1 = getTopFace(dice1);
      const v2 = getTopFace(dice2);
      console.log('planned:', r1, r2, 'measured(top):', v1, v2);

      // tek sekme
      const groundY = scene.userData.groundY;
      Promise.all([
        bounceOnce(dice1, { groundY, bounceHeight:0.12 }),
        bounceOnce(dice2, { groundY, bounceHeight:0.12 })
      ]).then(()=>{
        rolling = false;
        //lockAfterFirstRoll(); // tek atış istiyorsan aç
      });
    }
  }, 16);
}

/* ---------- loop ---------- */
function animate(){
  requestAnimationFrame(animate);

  // ilk atış öncesi yavaş idle
  if (!hasRolled && dice1 && dice2){
    const dt = clock.getDelta();
    const YAW = 0.25, TILT= 0.05;

    dice1.rotation.y += YAW*dt;
    dice2.rotation.y -= YAW*0.9*dt;

    dice1.rotation.x += Math.sin(performance.now()*0.001)*TILT*dt*0.2;
    dice2.rotation.z += Math.cos(performance.now()*0.0012)*TILT*dt*0.2;
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
